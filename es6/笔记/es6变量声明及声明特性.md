# es6变量声明及声明特性

。let：声明变量只在let所在的代码块内有效

。const声明一个只读的常量，一旦声明，常量的值就不能改变，而且一旦声明必须初始化，否则会报错

## 1.1、let和var的区别

。var声明变量在群居范围内有效

。let只能声明同明变量一次，var可以声明多次

。let不存在变量提升，var会变量提升

## 1.2、声明变量：

let a;

let d,b,c;

let e=100;

let f=111,g='你好'，h=[];

注意：

。变量不能重复声明

## 1.3、块级作用域   全局，函数，eval

{

​    let girl ='你好'；

}

console.log(girl);

程序报错

注意:

。 {{{...}}}块级作用域支持多层嵌套，每一层均为封闭，只作用于此

。et或 const 声明的变量只在 let 或 const 命令所在的代码块 {} 内有效，在 {} 之外不能访问。

## 1.4、不存在变量的提升

。var 变量提升是只会提升变量的声明，不会提升其初始化，如果一个变量先被使用再被声明和赋值的话，使用时的值是undefined

。var先赋值，再使用，最后声明该变量，使用时能获取所得到的值，就称为变量提升

## 1.5、不影响作用域链

ES5中的IIFE（立即执行匿名函数）不再必要了。

。es5没有块内作用域，只能用函数，但函数只能调用而不能立即执行，因此有了立即执行匿名函数

。立即执行函数：（function（x）{}  ）（x）

。理解为IIFE=块级作用域“{}”

es5只有全局作用域和函数作用域

![作用域链](C:\Users\86173\Desktop\es6\笔记\images\作用域链.png)

# 2、典型案例

![this](C:\Users\86173\Desktop\es6\笔记\images\this.png)

当在函数里面的this无法指向当前this

原因：this指向的是window，window没有style属性。拒绝方法外层函数保存this的值，里层函数的this找不到就会往外层找，如果外层有就不会去执行window里

# 注意：

call函数可以改变this的指向